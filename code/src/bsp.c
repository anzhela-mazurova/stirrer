/*****************************************************************************
* Model: stirrer.qm
* File:  ../src/bsp.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${../src::bsp.c} .........................................................*/
/* ----------------------------- 80 symbols --------------------------------- */
/* Board support package */
/* Stirrer */
/* UART2 used for console and qspy */
// #include "qpc.h"
#include "stirrer.h"
// #include "bsp.h"

/* PIC24FV32KA302 configuration bits */
/* 16 MHz FRC clock with PLL */
#pragma config BWRP=OFF, BSS=OFF, GWRP=OFF, GSS0=OFF
#pragma config FNOSC=FRCPLL, SOSCSRC=DIG, LPRCSEL=LP, IESO=OFF
#pragma config POSCMOD=NONE, OSCIOFNC=OFF, POSCFREQ=LS, SOSCSEL=SOSCLP
#pragma config FCKSM=CSDCMD, FWDTEN=OFF, WINDIS=OFF, LVRCFG = OFF // RETCFG = OFF
#pragma config BORV=V20, MCLRE=ON, ICS=PGx2, DSBOREN=OFF, DSWDTEN=OFF

#define BAUD_RATE_CONSOLE 115200UL

Q_DEFINE_THIS_FILE

#ifdef Q_SPY

    #define QS_BAUD_RATE      115200U
    #define QS_TXFIFO_DEPTH   1U    //rev.A4 tx fifo bug
    #define QS_BUF_SIZE 1024U
    #define QS_RX_SIZE  100U

    QSTimeCtr QS_tickTime_;
    QSTimeCtr QS_tickPeriod_;

    static uint8_t const l_T1Interrupt = 0;

#endif

/*${BSP::_AddressError} ....................................................*/
void __attribute__((__interrupt__,__no_auto_psv__)) _AddressError(void) {
    while(1);    //Address error
}
/*${BSP::_StackError} ......................................................*/
void __attribute__((__interrupt__,__no_auto_psv__)) _StackError(void) {
    while(1);
}
/*${BSP::_T1Interrupt} .....................................................*/
void  __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void) {
    /* ----------------------------- 80 symbols --------------------------------- */
    #define KEYS (portb & EBUT_MASK)

    typedef union {    //key specific
             uint8_t w;
             struct {
                 unsigned : 2;
                 unsigned ebut: 1;
                 unsigned : 5;
             } __attribute__ ((__packed__));
    } Ku;

    static QEvt const EnciEvt = { ENCI_SIG, 0U, 0U };
    static QEvt const EncdEvt = { ENCD_SIG, 0U, 0U };
    static QEvt const PressEvt = { PRESS_SIG, 0U, 0U };
    static QEvt const ReleaseEvt = { RELEASE_SIG, 0U, 0U };

    static const QEvt* const enc_states[] =         //encoder lookup table
        {0, &EncdEvt, &EnciEvt, 0, &EnciEvt, 0, 0, &EncdEvt, &EncdEvt, 0, 0,
             &EnciEvt, 0, &EnciEvt, &EncdEvt, 0};

    static uint8_t old_AB = 0;    //previous state of the encoder

    static uint8_t deb_idx = 0;   //index to button debounce history
    static Ku kbd[4];             //button debounce history
    static Ku keys = {0};         //debounced keys
    Ku les = {0};                 //leading edges
    Ku tes = {0};                 //trailing edges
    Ku oldk;                      //prev.state of debounced keys

    _T1IF = 0;                    /* clear interrupt flag */

    uint16_t porta = PORTA;       // read encoder and button
    uint16_t portb = PORTB;

    //process encoder
    old_AB <<= 2;                            // remember previous state
    old_AB |= ( porta & 0x0003 );            // add current state

    if ( enc_states[(old_AB & 0x0f)] ) { // other than zero
        QACTIVE_POST_X(AO_Front, enc_states[(old_AB & 0x0f)], 1, &l_T1Interrupt);
    }

    //process buttons
    deb_idx++;
    deb_idx &= 0x03;                 //wrap
    kbd[deb_idx].w = (uint8_t)KEYS;  //store current state of the keys
    oldk = keys;                     //store previous state of debounced keys

    keys.w |= kbd[0].w & kbd[1].w & kbd[2].w & kbd[3].w;  // All on  - set
    keys.w &= kbd[0].w | kbd[1].w | kbd[2].w | kbd[3].w;  // All off - clear

    les.w |= (keys.w ^ oldk.w) & keys.w;     // or in new leading edges
    tes.w |= (keys.w ^ oldk.w) & ~keys.w;    // or in new trailing edges

    if (les.ebut) {
        QACTIVE_POST_X(AO_Front, &ReleaseEvt, 1, &l_T1Interrupt);
    }

    if (tes.ebut) {
        QACTIVE_POST_X(AO_Front, &PressEvt, 1, &l_T1Interrupt);
    }

    #ifdef Q_SPY
        {
            QS_tickTime_ += QS_tickPeriod_; /* account for the clock rollover */
        }
    #endif

    QF_TICK_X(0U, &l_T1Interrupt); /* process time events for rate 0 */
}
/*${BSP::_U2RXInterrupt} ...................................................*/
void  __attribute__((__interrupt__, auto_psv)) _U2RXInterrupt(void) {
    while( U2STAbits.URXDA == 1 ) {    //receive buffer has data
    #ifdef Q_SPY
        uint32_t b = U2RXREG;
        QS_RX_PUT(b);
    #else
    //        MenuSelectEvt* mse = Q_NEW(MenuSelectEvt, MENU_SELECT_SIG);
    //        mse->key = U2RXREG;
    //        QACTIVE_POST( AO_CLI, (QEvt*)mse, &l_U2RXInterrupt );
    #endif
    }

    _U2RXIF = 0;
    //Input can be paced by disabling interrupt here and re-enabling in &Console
}
/**/
/*${BSP::BSP_init} .........................................................*/
void BSP_init(void) {
    /* ----------------------------- 80 symbols --------------------------------- */
    // _TRISB15 = 0;
    // REFOCONbits.ROEN = 1;   //output CPU clock for testing

    CLKDIVbits.RCDIV = 0b000;    // no postscaler
    RCONbits.SWDTEN = 0; /* disable Watchdog */

    /* configure I/O ports */
    ANSA = 0;    // analog out on port A
    ANSB = 0;    // analog out on port B

    /* SPI2 init */

    SCLK_TRIS = 0;
    MOSI_TRIS = 0;
    ALCS_PIN = 1;    //deassert CS
    ALCS_TRIS = 0;
    PWM_TRIS = 0;
    PWM_PIN = 1;

    SPI2CON1bits.MSTEN = 1;    // master mode
    SPI2CON1bits.MODE16 = 1;   // 16-bit xfer
    SPI2CON1bits.CKE = 1;      // clock edge
    SPI2CON1bits.SPRE = 0b111;  // 1:1
    SPI2CON1bits.PPRE = 0b10;  // 4:1
    SPI2STATbits.SPIROV = 0;    // FRM DS39699B-page 23-10
    SPI2STATbits.SPIEN = 1;    // enable module

    /* OC1 init */

    OC1CON1bits.OCTSEL = 0b111;        // clock FCY
    OC1CON2bits.SYNCSEL = 0b11111;    // sync to self
    OC1R = 30;
    OC1RS = 500;
    OC1CON1bits.OCM = 0b110;       // enable in edge PWM mode

    /* IC2 init */
    IC2CON2bits.SYNCSEL = 0;    // do not sync
    IC2CON1bits.IC2TSEL = 0b100;    // Timer 1
    IC2CON1bits.ICM = 0b011;    // capture on every rising edge
    IC2CON1bits.ICI = 0b11;     // generate interrupt every 4th capture

    /* Encoder */
    EBUT_PULLUP = 1;
    ENCA_PULLUP = 1;
    ENCB_PULLUP = 1;

    /* Display */

    E_TRIS = 0;

    BL_TRIS = 0;    // backlight
    BL_PIN = 0;

    RS_TRIS = 0;

    D4_TRIS = 0;
    D5_TRIS = 0;
    D6_TRIS = 0;
    D7_TRIS = 0;

    /* Display Init */
    static const uint8_t const init_nibble[] = {
          0x03, 0x03, 0x03, 0x02,    // switch to 4-bit
          0x02, 0x08,    // Func.set 4 bit, 2 lines
          0x00, 0x08,    // Display Off
          0x00, 0x01,    // Clear Display
          0x00, 0x06,    // Entry Mode Set
          0x00, 0x0c,    // Display On
    };

    RS_PIN = 0;    //

    __delay_ms(100);
    int8_t i;

    for ( i = 0; i < Q_DIM(init_nibble); i++ ) {

        LATB &= ~DISP_DATA;    // clean display data lines
        LATB |= ( init_nibble[ i ] << 12 );
        __delay_us(1);
        E_PIN = 1;        // strobe E
        __delay_us(1);
        E_PIN = 0;
        __delay_ms(3);
    }

    /* Initialize timers */
}
/*${BSP::QF_onStartup} .....................................................*/
void QF_onStartup(void) {
    /* Timer 1 - provides system tick */
    T1CON = 0x0010U;  /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 8 */
    TMR1  = 0x0000U; /* Start counting from 0 and clear the prescaler count */
    PR1   = (uint16_t)(BSP_TMR1_PERIOD - 1U);              /* Timer1 period */
    //_T1IP = TIMER1_ISR_PRIO;           /* set Timer 1 interrupt priority  */
    _T1IF = 0;                           /* clear the interrupt for Timer 1 */
    _T1IE = 1;                              /* enable interrupt for Timer 1 */
    T1CONbits.TON = 1;                                     /* start Timer 1 */

    /* Timer 2 - sends out LCD data */
    T2CON = 0x0000U;  /* Use Internal Osc (Fcy), 16 bit mode, prescaler = 1 */
    TMR2  = 0x0000U; /* Start counting from 0 and clear the prescaler count */
    PR2   = 1U;              /* Timer2 period */
    //_T2IP = TIMER2_ISR_PRIO;              /* set Timer 1 interrupt priority */
    _T2IF = 0;                           /* clear the interrupt for Timer 1 */
    /* Timer 2 interrupt enabled by data - not here */

    /* initialize UART2 */
    TX_TRIS = 0;
    U2STA  = 0x0000U;                        /* use default settings of 8N1 */
    U2STAbits.UTXISEL1 = 1;    /* interrupt on empty Tx */
    U2MODE = 0x0008U;                              /* enable high baud rate */

    #ifdef Q_SPY
        U2BRG  = ((FCY / 4 / QS_BAUD_RATE) - 1);
    #else
        U2BRG  = ((FCY / 4 / BAUD_RATE_CONSOLE) - 1);
    #endif

    U2MODEbits.UARTEN = 1; //UART then Tx - in that order!
    U2STAbits.UTXEN   = 1;

    uint8_t tmpdata = U2RXREG;       //clear RX errors
    U2STAbits.FERR = 0;
    U2STAbits.OERR = 0;

    /* UART2 Tx interrupt enabled by data - not here */
    _U2RXIF = 0;
    _U2ERIF = 0;

    /* UART2 Rx */
    _U2RXIE = 1;    // enable UART2 Rx Interrupt

    _IC2IE = 1;    // enable IC2 interrupt

    #ifdef Q_SPY

    if (QS_INIT((void *)0) == 0) {    /* initialize the QS software tracing */
        Q_ERROR();
    }
    QS_RESET();
    QS_OBJ_DICTIONARY(&l_T1Interrupt);
    QS_USR_DICTIONARY(A1_STAT);
    QS_USR_DICTIONARY(COMMAND_STAT);
    QS_USR_DICTIONARY(CONSOLE_OUT);

    #endif    // Q_SPY
}
/*${BSP::QF_onCleanup} .....................................................*/
void QF_onCleanup(void) {
    /* empty */
}
/*${BSP::Q_onAssert} .......................................................*/
void Q_onAssert(char const* module, int loc) {
    (void)module;
    (void)loc;
    QS_ASSERTION(module, loc, (uint32_t)10000U); /* report assertion to QS */
    for (;;) {}
}
/*${BSP::QV_onIdle} ........................................................*/
void QV_onIdle(void) {
    /* UART code is PIC24FxxxKA3xx-specific */
    #ifdef Q_SPY
        QF_INT_ENABLE();
        QS_rxParse();  /* parse all the received bytes */

        if (U2STAbits.TRMT == 1) {  /* TX done? */
            uint16_t fifo = QS_TXFIFO_DEPTH;   /* max bytes we can accept */
            uint8_t const *block;

            QF_INT_DISABLE();
            block = QS_getBlock(&fifo);  /* try to get next block to transmit */
            QF_INT_ENABLE();

            while (fifo-- != 0) {        /* any bytes in the block? */
                U2TXREG = *block++;    /* put into the FIFO */
            }
        }//if (U2STAbits.TRMT...
    #elif defined NDEBUG
        /* Put the CPU and peripherals to the low-power mode.
        * you might need to customize the clock management for your application
        */
        QV_CPU_SLEEP();  /* atomically go to sleep and enable interrupts */
    #else
        QF_INT_ENABLE(); /* just enable interrupts */
    #endif

    #if 0
           __asm__ volatile("disi #0x0001");
            Idle();                          /* transition to Idle mode, see NOTE02 */
        #else

    #endif    // 0
}
#ifdef Q_SPY
/* QS functions */
/*${BSP::QS_onStartup} .....................................................*/
uint8_t QS_onStartup(void const* arg) {
    static uint8_t qsTxBuf[QS_BUF_SIZE]; /* buffer for QS transmit channel */
    static uint8_t qsRxBuf[100];    /* buffer for QS receive channel */
    uint8_t tmpdata;

        QS_initBuf  (qsTxBuf, sizeof(qsTxBuf));
        QS_rxInitBuf(qsRxBuf, sizeof(qsRxBuf));
        QS_tickPeriod_ = BSP_TMR1_PERIOD;
        QS_tickTime_ = QS_tickPeriod_; /* to start the timestamp at zero */
                                       /* setup the QS filters... */
        QS_FILTER_OFF(QS_ALL_RECORDS);

        // Let us know when we add dictionary entries
        QS_FILTER_ON(QS_SIG_DICT);
        QS_FILTER_ON(QS_OBJ_DICT);
        QS_FILTER_ON(QS_FUN_DICT);
        QS_FILTER_ON(QS_USR_DICT);

        // QS_FILTER_ON(QS_QF_TICK);
        QS_FILTER_ON(CONSOLE_OUT);
        QS_FILTER_ON(QS_QF_ACTIVE_POST_FIFO);
        QS_FILTER_ON(QS_QEP_STATE_ENTRY);
        QS_FILTER_ON(QS_QEP_STATE_EXIT);

    #if 0

    //    QS_FILTER_OFF(QS_QEP_STATE_EMPTY);
    //    QS_FILTER_OFF(QS_QEP_STATE_ENTRY);
    //    QS_FILTER_OFF(QS_QEP_STATE_EXIT);
    //    QS_FILTER_OFF(QS_QEP_STATE_INIT);
    //    QS_FILTER_OFF(QS_QEP_INIT_TRAN);
    //    QS_FILTER_OFF(QS_QEP_INTERN_TRAN);
    //    QS_FILTER_OFF(QS_QEP_TRAN);
    //    QS_FILTER_OFF(QS_QEP_dummyD);

        QS_FILTER_OFF(QS_QF_ACTIVE_ADD);
        QS_FILTER_OFF(QS_QF_ACTIVE_REMOVE);
        QS_FILTER_OFF(QS_QF_ACTIVE_SUBSCRIBE);
        QS_FILTER_OFF(QS_QF_ACTIVE_UNSUBSCRIBE);
        QS_FILTER_OFF(QS_QF_ACTIVE_POST_FIFO);
        QS_FILTER_OFF(QS_QF_ACTIVE_POST_LIFO);
        QS_FILTER_OFF(QS_QF_ACTIVE_GET);
        QS_FILTER_OFF(QS_QF_ACTIVE_GET_LAST);
        QS_FILTER_OFF(QS_QF_EQUEUE_INIT);
        QS_FILTER_OFF(QS_QF_EQUEUE_POST_FIFO);
        QS_FILTER_OFF(QS_QF_EQUEUE_POST_LIFO);
        QS_FILTER_OFF(QS_QF_EQUEUE_GET);
        QS_FILTER_OFF(QS_QF_EQUEUE_GET_LAST);
        QS_FILTER_OFF(QS_QF_MPOOL_INIT);
        QS_FILTER_OFF(QS_QF_MPOOL_GET);
        QS_FILTER_OFF(QS_QF_MPOOL_PUT);
        QS_FILTER_OFF(QS_QF_PUBLISH);
        QS_FILTER_OFF(QS_QF_NEW);
        QS_FILTER_OFF(QS_QF_GC_ATTEMPT);
        QS_FILTER_OFF(QS_QF_GC);
    //    QS_FILTER_OFF(QS_QF_TICK);
        QS_FILTER_OFF(QS_QF_TIMEEVT_ARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_AUTO_DISARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_DISARM_ATTEMPT);
        QS_FILTER_OFF(QS_QF_TIMEEVT_DISARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_REARM);
        QS_FILTER_OFF(QS_QF_TIMEEVT_POST);
        QS_FILTER_OFF(QS_QF_CRIT_ENTRY);
        QS_FILTER_OFF(QS_QF_CRIT_EXIT);
        QS_FILTER_OFF(QS_QF_ISR_ENTRY);
        QS_FILTER_OFF(QS_QF_ISR_EXIT);

    #endif    // 0

        QS_SIG_DICTIONARY(READY_SIG, 0);
        QS_SIG_DICTIONARY(ENCI_SIG, 0);
        QS_SIG_DICTIONARY(ENCD_SIG, 0);
        QS_SIG_DICTIONARY(LEFT_SIG, 0);
        QS_SIG_DICTIONARY(RIGHT_SIG, 0);
        QS_SIG_DICTIONARY(PRESS_SIG, 0);
        QS_SIG_DICTIONARY(RELEASE_SIG, 0);
        QS_SIG_DICTIONARY(CLICK_SIG, 0);
        QS_SIG_DICTIONARY(HOLD_SIG, 0);
        QS_SIG_DICTIONARY(KEY_SIG, 0);
        QS_SIG_DICTIONARY(BLINK_SIG, 0);
        QS_SIG_DICTIONARY(WARNING_SIG, 0);
        QS_SIG_DICTIONARY(FAULT_SIG, 0);
        QS_SIG_DICTIONARY(HEARTBEAT_SIG, 0);
        QS_SIG_DICTIONARY(NAV_TIMEOUT_SIG, 0);
        QS_SIG_DICTIONARY(HOLD_TIMEOUT_SIG, 0);

        /* set object dictionaries for AOs */
        QS_OBJ_DICTIONARY(AO_Front);
    //    QS_OBJ_DICTIONARY(AO_Control);

        QS_FUN_DICTIONARY(&NavGen_initial);
        QS_FUN_DICTIONARY(&NavGen_HandleEncoder);
        QS_FUN_DICTIONARY(&NavGen_Released);
        QS_FUN_DICTIONARY(&NavGen_Pressed);

        return (uint8_t)1;            /* indicate successfull QS initialization */
}
/*${BSP::QS_onCleanup} .....................................................*/
void QS_onCleanup(void) {
    /* empty */
}
/*${BSP::QS_onGetTime} .....................................................*/
QSTimeCtr QS_onGetTime(void) {
    if (_T1IF == 0) {

        return QS_tickTime_ + (uint32_t)TMR1;

    } else {

        return QS_tickTime_ + QS_tickPeriod_ + (uint32_t)TMR1;
    }
}
/*${BSP::QS_onFlush} .......................................................*/
void QS_onFlush(void) {
    uint16_t fifo = QS_TXFIFO_DEPTH; /* Tx FIFO depth */
    uint8_t const *block;

        QF_INT_DISABLE();
        while ((block = QS_getBlock(&fifo)) != (uint8_t *)0) {
            QF_INT_ENABLE();
            /* busy-wait as long as TX FIFO has data to transmit */
            while (U2STAbits.TRMT == 0) {
            }

            while (fifo-- != 0) {    /* any bytes in the block? */
                U2TXREG = *block++; /* put into the TX FIFO */
            }
            fifo = QS_TXFIFO_DEPTH; /* re-load the Tx FIFO depth */
            QF_INT_DISABLE();
        }
        QF_INT_ENABLE();
}
/*${BSP::QS_onReset} .......................................................*/
void QS_onReset(void) {
    __asm__ volatile ("reset");
}
/*${BSP::QS_onCommand} .....................................................*/
void QS_onCommand(uint8_t cmdId, uint32_t param) {
    void assert_failed(char const *module, int loc);
    (void)cmdId;
    (void)param;
    QS_BEGIN(COMMAND_STAT, (void *)0) /* application-specific record begin */
        QS_U8(2, cmdId);
        QS_U32(8, param);
    QS_END()

    if (cmdId == 10U) {
        Q_ERROR();
    }
    else if (cmdId == 11U) {
        Q_onAssert("QS_onCommand", 123);
    }
}
#endif


