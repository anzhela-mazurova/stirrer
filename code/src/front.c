/*****************************************************************************
* Model: stirrer.qm
* File:  ../src/front.c
*
* This code has been generated by QM tool (see state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*****************************************************************************/
/*${../src::front.c} .......................................................*/
/* ----------------------------- 80 symbols --------------------------------- */
// #include "qpc.h"
#include "stirrer.h"
// #include "bsp.h"

#include <string.h>

Q_DEFINE_THIS_FILE


#if ((QP_VERSION < 580) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8)))
#error qpc version 5.8.0 or higher required
#endif

/*${AOs::Front} ............................................................*/
typedef struct {
/* protected: */
    QActive super;

/* private: */
    QTimeEvt RdyTimeEvt;
    QTimeEvt HoldTimeEvt;
    NavGen navgen;

/* private state histories */
    QStateHandler his_Dashboard;
} Front;

/* private: */
static void Front_blankBuf(void);
static void Front_printStr(const char* str);
static void Front_printNum(uint32_t num, uint8_t base);
static void Front_printRoll(void);
static void Front_NavGen_ctor(NavGen* const me);
static uint16_t Front_a4960Xfer(uint8_t reg, uint16_t data);

/* protected: */
static QState Front_initial(Front * const me, QEvt const * const e);
static QState Front_Startup(Front * const me, QEvt const * const e);
static QState Front_Operational(Front * const me, QEvt const * const e);
static QState Front_Navigate(Front * const me, QEvt const * const e);
static QState Front_Edit(Front * const me, QEvt const * const e);
static QState Front_Dashboard(Front * const me, QEvt const * const e);
static QState Front_Idle(Front * const me, QEvt const * const e);
static QState Front_Run(Front * const me, QEvt const * const e);

/* Numeric output TODO: replace with a pointer queue */
void itoa(uint16_t n, uint8_t s[]);
void reverse(uint8_t s[]);

/* Moving average weight. Must be power of 2 */
#define RPM_WEIGHT 4

static struct ewma {    // averaged tachometer
    uint16_t internal;
    uint8_t weight;
} avg_rpm;

/* EWMA related */
void ewma_init(struct ewma *avg, uint8_t weight);

uint16_t ewma_add(struct ewma* avg, uint16_t val);

/* PID related */
// x - control signal (PWM)

#define N 1U    // prop.shift range 1 - 16
#define NMIN -(1<<(15+N))
#define NMAX (1<<(15+N))-1


int16_t pid_update(uint16_t tacho);

// AO Timers
#define READY_TIME 10U
#define HOLD_TIME BSP_TICKS_PER_SEC*2

//Console TX buffer - must be power of 2
#ifndef Q_SPY

#define CONSOLE_TX_BUFSIZE 16

#else    // qspy uses this uart

#define CONSOLE_TX_BUFSIZE 1

#endif

#define CONSOLE_TX_BUFMASK ( CONSOLE_TX_BUFSIZE - 1 )

#if ( CONSOLE_TX_BUFSIZE & CONSOLE_TX_BUFMASK )
#error Serial Tx Buffer size is not a power of 2
#endif

/* A4960 constants */
#define A4960_CONF0_RD 0
#define A4960_CONF0_WR 1
#define A4960_CONF1_RD 2
#define A4960_CONF1_WR 3
#define A4960_CONF2_RD 4
#define A4960_CONF2_WR 5
#define A4960_CONF3_RD 6
#define A4960_CONF3_WR 7
#define A4960_CONF4_RD 8
#define A4960_CONF4_WR 9
#define A4960_CONF5_RD 0x0a
#define A4960_CONF5_WR 0x0b
#define A4960_MASK_RD 0x0c
#define A4960_MASK_WR 0x0d
#define A4960_RUN_RD 0x0e
#define A4960_RUN_WR 0x0f





/* Local objects -----------------------------------------------------------*/
static Front l_front;     /* the single instance of the Front AO */



// Serial console
static const char* ConsoleTx_Buf[ CONSOLE_TX_BUFSIZE ];
static uint8_t ConsoleTx_Head;
static volatile uint8_t ConsoleTx_Tail;    //interrupt changes this
static const char* pPrintStr;   //stores a string being output

// Display

static uint8_t display_buffer[32] = {"Quick Brown Fox Jumps Over"};

/* Directory Screens */

/* Parameter Screens */

/* Parameters */

// Set RPM
static int16_t SetRpm = 100;

// Number of pole pairs in a brushless motor attached
// Affects RPM
static uint8_t PolePairs = 14;

// Encoder Sensitivity
static int8_t EncoderSensIdx = 4;
static char* EncoderSensList[] =
    {"Very High" ,"High" ,"Medium" ,"Low" ,"Very Low" };

/* Constituent SMs */
/*${AOs::NavGen} ...........................................................*/
/*${AOs::NavGen::SM} .......................................................*/
QState NavGen_initial(NavGen * const me, QEvt const * const e) {
    /* ${AOs::NavGen::SM::initial} */
    me->encval = 0;
    return Q_TRAN(&NavGen_Released);
}
/*${AOs::NavGen::SM::HandleEncoder} ........................................*/
QState NavGen_HandleEncoder(NavGen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::NavGen::SM::HandleEncoder::ENCI} */
        case ENCI_SIG: {
            static QEvt const RightEvt = { RIGHT_SIG, 0U, 0U };

            if ( ++me->encval >  EncoderSensIdx ) {

                QACTIVE_POST_X(AO_Front, &RightEvt, 1, me);
                me->encval = 0;
            }
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::NavGen::SM::HandleEncoder::ENCD} */
        case ENCD_SIG: {
            static QEvt const LeftEvt = { LEFT_SIG, 0U, 0U };

            if (( --me->encval + EncoderSensIdx ) < 0 ) {

                me->encval = 0;
                QACTIVE_POST_X(AO_Front, &LeftEvt, 1, me);
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::NavGen::SM::HandleEncoder::Released} ..............................*/
QState NavGen_Released(NavGen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::NavGen::SM::HandleEncoder::Released::PRESS} */
        case PRESS_SIG: {
            status_ = Q_TRAN(&NavGen_Pressed);
            break;
        }
        default: {
            status_ = Q_SUPER(&NavGen_HandleEncoder);
            break;
        }
    }
    return status_;
}
/*${AOs::NavGen::SM::HandleEncoder::Pressed} ...............................*/
QState NavGen_Pressed(NavGen * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::NavGen::SM::HandleEncoder::Pressed::HOLD_TIMEOUT} */
        case HOLD_TIMEOUT_SIG: {
            static QEvt const HoldEvt = { HOLD_SIG, 0U, 0U };
            QACTIVE_POST_X(AO_Front, &HoldEvt, 1, me);
            status_ = Q_TRAN(&NavGen_Released);
            break;
        }
        /* ${AOs::NavGen::SM::HandleEncoder::Pressed::RELEASE} */
        case RELEASE_SIG: {
            static QEvt const ClickEvt = { CLICK_SIG, 0U, 0U };
            QACTIVE_POST_X(AO_Front, &ClickEvt, 1, me);
            status_ = Q_TRAN(&NavGen_Released);
            break;
        }
        default: {
            status_ = Q_SUPER(&NavGen_HandleEncoder);
            break;
        }
    }
    return status_;
}



/* Global-scope objects ----------------------------------------------------*/
QActive* const AO_Front = &l_front.super; /* "opaque" AO pointer */

/*${AOs::Front_ctor} .......................................................*/
void Front_ctor(void) {
    Front *me = &l_front;
    QActive_ctor(&me->super, Q_STATE_CAST(&Front_initial));
    // Time event constructors
    QTimeEvt_ctorX(&me->RdyTimeEvt, &me->super, READY_SIG, 0U);
    QTimeEvt_ctorX(&me->HoldTimeEvt, &me->super, HOLD_TIMEOUT_SIG, 0U);
    // Nav.Generator SM
    Front_NavGen_ctor(&me->navgen);
    QHSM_INIT((QHsm*)&me->navgen,(QEvt*)0);

    QS_FUN_DICTIONARY(&Front_Startup);
}
/*${AOs::Front} ............................................................*/
/*${AOs::Front::blankBuf} ..................................................*/
static void Front_blankBuf(void) {
    int8_t i;    //index

    for ( i = 0; i < Q_DIM( display_buffer ); i++ ) {

        display_buffer[ i ] = 0x20;
    }
}
/*${AOs::Front::printStr} ..................................................*/
static void Front_printStr(const char* str) {
    /* ----------------------------- 80 symbols --------------------------------- */
    #ifdef Q_SPY    //suppress UART output and print string as an app.record

        QS_BEGIN( CONSOLE_OUT, AO_Front )
            QS_STR( str );
        QS_END()
        return;

    #else    // Q_SPY

    uint8_t tmphead = ConsoleTx_Head + 1;

    #if CONSOLE_TX_BUFMASK < 255
        tmphead &= CONSOLE_TX_BUFMASK;
    #endif

        while ( tmphead == ConsoleTx_Tail ) {}     //this line blocks! return from the brackets

        ConsoleTx_Buf[ tmphead ] = /*(const uint8_t*)*/str;

        ConsoleTx_Head = tmphead;

        if ( _U2TXIE == 0) {    //trigger interrupt
            _U2TXIF = 1;
            _U2TXIE = 1;
        }
    #endif    // Q_SPY
}
/*${AOs::Front::printNum} ..................................................*/
static void Front_printNum(uint32_t num, uint8_t base) {
    #define CHAR_BUFSIZE 33
     const char* const numchars[] = {"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"};
     const char* buf[CHAR_BUFSIZE];
     const char** pStr = &(buf[CHAR_BUFSIZE-1]);

        do {

            *(--pStr) = numchars[num % base];

            num /= base;
        } while( num != 0 );

        while( pStr < &buf[CHAR_BUFSIZE-1] ) {    //copy the buffer into the queue

            Front_printStr( *pStr++ );
        }
}
/*${AOs::Front::printRoll} .................................................*/
static void Front_printRoll(void) {
    #define IDX_MASK 3
     const char* const rollchar[4] = {"/","-","\\","|"};
     static uint8_t idx = 0;

        Front_printStr("\x08");    //backspace

        Front_printStr( rollchar[idx++] );

        idx &= IDX_MASK;
}
/*${AOs::Front::NavGen_ctor} ...............................................*/
static void Front_NavGen_ctor(NavGen* const me) {
    QHsm_ctor(&me->super, Q_STATE_CAST(&NavGen_initial));
}
/*${AOs::Front::a4960Xfer} .................................................*/
static uint16_t Front_a4960Xfer(uint8_t reg, uint16_t data) {
    ALCS_PIN = 0;    //assert CS

    SPI2BUF = (( reg << 12 ) | ( data & 0x0fff ));

    while(SPI2STATbits.SPIRBF == 0);    //wait till end of xfer

    ALCS_PIN = 1;    //assert CS

    return( SPI2BUF );
}
/*${AOs::Front::SM} ........................................................*/
static QState Front_initial(Front * const me, QEvt const * const e) {
    /* ${AOs::Front::SM::initial} */
    ConsoleTx_Head = 0;
    ConsoleTx_Tail = 0;
    /* state history attributes */
    me->his_Dashboard = Q_STATE_CAST(&Front_Idle);
    return Q_TRAN(&Front_Startup);
}
/*${AOs::Front::SM::Startup} ...............................................*/
static QState Front_Startup(Front * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Front::SM::Startup} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->RdyTimeEvt, READY_TIME, 0U);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Startup} */
        case Q_EXIT_SIG: {
            Front_printStr("Stirrer Serial Console\r\n");
            Front_printStr("Compiled on ");
            Front_printStr(__DATE__);
            Front_printStr(" ");
            Front_printStr(__TIME__);
            Front_printStr(" using Microchip xc16 ver.");
            Front_printNum(__XC16_VERSION__, 10);
            Front_printStr("\r\nQuantum Leaps QP ver.");
            Front_printStr(QP_VERSION_STR);
            Front_printStr("\r\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Startup::READY} */
        case READY_SIG: {
            status_ = Q_TRAN(&Front_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Front::SM::Operational} ...........................................*/
static QState Front_Operational(Front * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Front::SM::Operational::ENCI, ENCD, HOLD_TIMEOUT} */
        case ENCI_SIG: /* intentionally fall through */
        case ENCD_SIG: /* intentionally fall through */
        case HOLD_TIMEOUT_SIG: {
            QHSM_DISPATCH(Q_HSM_UPCAST(&me->navgen),((QEvt*)(e)));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Operational::PRESS} */
        case PRESS_SIG: {
            QTimeEvt_armX(&me->HoldTimeEvt, HOLD_TIME, 0U);
            QHSM_DISPATCH(Q_HSM_UPCAST(&me->navgen),((QEvt*)(e)));
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Operational::RELEASE} */
        case RELEASE_SIG: {
            QTimeEvt_disarm(&me->HoldTimeEvt);
            QHSM_DISPATCH(Q_HSM_UPCAST(&me->navgen),((QEvt*)(e)));
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*${AOs::Front::SM::Operational::Navigate} .................................*/
static QState Front_Navigate(Front * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Front::SM::Operational::Navigate::CLICK} */
        case CLICK_SIG: {
            status_ = Q_TRAN(&Front_Edit);
            break;
        }
        /* ${AOs::Front::SM::Operational::Navigate::RIGHT} */
        case RIGHT_SIG: {
            status_ = Q_TRAN(&Front_Navigate);
            break;
        }
        /* ${AOs::Front::SM::Operational::Navigate::LEFT} */
        case LEFT_SIG: {
            status_ = Q_TRAN(&Front_Navigate);
            break;
        }
        /* ${AOs::Front::SM::Operational::Navigate::HOLD, NAV_TIMEOUT} */
        case HOLD_SIG: /* intentionally fall through */
        case NAV_TIMEOUT_SIG: {
            status_ = Q_TRAN_HIST(me->his_Dashboard);
            break;
        }
        default: {
            status_ = Q_SUPER(&Front_Operational);
            break;
        }
    }
    return status_;
}
/*${AOs::Front::SM::Operational::Edit} .....................................*/
static QState Front_Edit(Front * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Front::SM::Operational::Edit::CLICK} */
        case CLICK_SIG: {
            status_ = Q_TRAN(&Front_Navigate);
            break;
        }
        /* ${AOs::Front::SM::Operational::Edit::RIGHT} */
        case RIGHT_SIG: {
            status_ = Q_TRAN(&Front_Edit);
            break;
        }
        /* ${AOs::Front::SM::Operational::Edit::LEFT} */
        case LEFT_SIG: {
            status_ = Q_TRAN(&Front_Edit);
            break;
        }
        /* ${AOs::Front::SM::Operational::Edit::HOLD, NAV_TIMEOUT} */
        case HOLD_SIG: /* intentionally fall through */
        case NAV_TIMEOUT_SIG: {
            status_ = Q_TRAN(&Front_Navigate);
            break;
        }
        default: {
            status_ = Q_SUPER(&Front_Operational);
            break;
        }
    }
    return status_;
}
/*${AOs::Front::SM::Operational::Dashboard} ................................*/
static QState Front_Dashboard(Front * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Front::SM::Operational::Dashboard} */
        case Q_EXIT_SIG: {
            /* save deep history */
            me->his_Dashboard = QHsm_state(me);
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::LEFT} */
        case LEFT_SIG: {
            /* go to end of parameters sequence */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::RIGHT} */
        case RIGHT_SIG: {
            /* go to beginning of parameters sequence */
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::HOLD} */
        case HOLD_SIG: {
            /* go to beginning of settings sequence */
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Front_Operational);
            break;
        }
    }
    return status_;
}
/*${AOs::Front::SM::Operational::Dashboard::Idle} ..........................*/
static QState Front_Idle(Front * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Front::SM::Operational::Dashboard::Idle} */
        case Q_ENTRY_SIG: {
            const uint8_t const idle[] = {"IDLE"};
            const uint8_t const rpm[] = {" RPM"};
            uint8_t buf[6] = {0};

            Front_blankBuf();
            memcpy( display_buffer, idle, ( Q_DIM(idle) - 1 ));
            itoa( SetRpm, buf );
            memcpy( display_buffer + 12U - strlen((const char*)(buf)),
                buf, strlen((const char*)(buf)));

            memcpy( display_buffer + 12U, rpm, ( Q_DIM(rpm) - 1 ));

            T2CONbits.TON = 1;        /* start timer */
            _T2IF = 1;                /* set interrupt flag */
            _T2IE = 1;                /* enable interrupt */
            Front_printStr("Idle\r\n");
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::Idle::CLICK} */
        case CLICK_SIG: {
            /* start the motor using current rev and ramp */
            uint32_t tmpdata = Front_a4960Xfer(A4960_RUN_RD,0U);         //read RUN register
                QS_BEGIN( CONSOLE_OUT, AO_Front )
                    QS_U32_HEX( 8, tmpdata );
                QS_END()
            tmpdata = 0x01;    // set RUN bit

            Front_a4960Xfer(A4960_RUN_WR, 1U );
            status_ = Q_TRAN(&Front_Run);
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::Idle::RIGHT} */
        case RIGHT_SIG: {
            SetRpm++;
            status_ = Q_TRAN(&Front_Idle);
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::Idle::LEFT} */
        case LEFT_SIG: {
            SetRpm--;
            status_ = Q_TRAN(&Front_Idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&Front_Dashboard);
            break;
        }
    }
    return status_;
}
/*${AOs::Front::SM::Operational::Dashboard::Run} ...........................*/
static QState Front_Run(Front * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /* ${AOs::Front::SM::Operational::Dashboard::Run} */
        case Q_ENTRY_SIG: {
            const uint8_t const run[] = {"RUN"};

            Front_printStr("Run\r\n");

            Front_blankBuf();
            memcpy( display_buffer, run, ( Q_DIM(run) - 1 ));

            T2CONbits.TON = 1;        /* start timer */
            _T2IF = 1;                /* set interrupt flag */
            _T2IE = 1;                /* enable interrupt */

            ewma_init( &avg_rpm, RPM_WEIGHT );
            status_ = Q_HANDLED();
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::Run::CLICK} */
        case CLICK_SIG: {
            uint32_t tmpdata = Front_a4960Xfer(A4960_RUN_RD,0U);         //read RUN register
                QS_BEGIN( CONSOLE_OUT, AO_Front )
                    QS_U32_HEX( 8, tmpdata );
                QS_END()
            tmpdata = 0;    // clear RUN bit

            Front_a4960Xfer(A4960_RUN_WR, 0U );
            status_ = Q_TRAN(&Front_Idle);
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::Run::RIGHT} */
        case RIGHT_SIG: {
            OC1R++;
            status_ = Q_TRAN(&Front_Run);
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::Run::LEFT} */
        case LEFT_SIG: {
            // SetRpm--;

            OC1R--;
            status_ = Q_TRAN(&Front_Run);
            break;
        }
        /* ${AOs::Front::SM::Operational::Dashboard::Run::TACHO} */
        case TACHO_SIG: {
            const uint8_t const run[] = {"RUN"};
            const uint8_t const rpm[] = {" RPM"};
            uint8_t buf[6] = {0};

            Front_blankBuf();

            memcpy( display_buffer, run, ( Q_DIM(run) - 1 ));

            itoa( Q_EVT_CAST(TachoEvt)->val, buf );

            memcpy( display_buffer + 12U - strlen((const char*)(buf)),
                buf, strlen((const char*)(buf)));

            memcpy( display_buffer + 12U, rpm, ( Q_DIM(rpm) - 1 ));

            T2CONbits.TON = 1;        /* start timer */
            _T2IF = 1;                /* set interrupt flag */
            _T2IE = 1;                /* enable interrupt */

            Front_printStr("Run\r\n");
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&Front_Dashboard);
            break;
        }
    }
    return status_;
}

/*${BSP::_U2TXInterrupt} ...................................................*/
void  __attribute__((__interrupt__, auto_psv)) _U2TXInterrupt(void) {
    _U2TXIF = 0;

        // while( U2STAbits.UTXBF == 0 ) {    //UART buffer available

            if( *pPrintStr ) {             //previous string not completed
                U2TXREG = *pPrintStr++;
            }//if( *pPrintStr...
            else {                         //get next string

                if( ConsoleTx_Head != ConsoleTx_Tail ) {    //data available

                    ConsoleTx_Tail++;
    #if CONSOLE_TX_BUFMASK < 255
                    ConsoleTx_Tail &= CONSOLE_TX_BUFMASK;
    #endif //CONSOLE_TX_BUFMASK < 255

                    pPrintStr = ConsoleTx_Buf[ ConsoleTx_Tail ];
                    _U2TXIF = 1;

                }//if( ConsoleTx_Head != ConsoleTx_Tail...
                else {    //queue empty

                    _U2TXIE = 0;    //disable interrupt
                    return;    //IF not cleaned - bug?
                }
            }//else - get next string
        // }//while( U2STAbits.UTXBF == 0...


}
/*${BSP::_T2Interrupt} .....................................................*/
void  __attribute__((__interrupt__, auto_psv)) _T2Interrupt(void) {
    /* ----------------------------- 80 symbols --------------------------------- */
    #define E_DELAY FCY/1000000UL    // 1 us E strobe margins
    #define XFER_DELAY 40*E_DELAY    // 40 us delay between transfers

    static uint8_t state = 0;    // Bit bang SM state
    static int8_t i = 0;         // buffer index
    // static uint8_t* buf = display_buffer;
    uint8_t data;



    T2CONbits.TON = 0;        /* stop the timer */
    _T2IF = 0;                    /* clear interrupt flag */

    switch( state ) {

        case 0:    // send line

            RS_PIN = 1;  //set data register
            data = display_buffer [ i++ ];
            if ( i == 16U ) {

                state++;
            }
            if ( i == 32U ) {

                i = 0;
                state++;
            }
            break;

        case 1:    // switch lines

            RS_PIN = 0;    // set command register
            if ( i == 0 ) {

                data = 0x80;    // set first line
                state++;        // this is last byte
            }
            else {

                data = 0xc0;    // set second line
                state--;        // keep output the data
            }
            break;

        case 2:        // stop

            _T2IE = 0;
            T2CONbits.TON = 0;
            state = 0;    // reset the machine
            return;       // do not send any data
    }

    /* do the transfer */
    LATB &= ~DISP_DATA;                // clean display data lines
    LATB |= (( data << 8 ) & 0xf000 ); //assert upper nibble
    E_PIN = 1;                         // strobe E
    E_PIN = 0;
    LATB &= ~DISP_DATA;     // clean display data lines
    LATB |= ( data << 12 ); //assert lower nibble
    E_PIN = 1;              // strobe E
    E_PIN = 0;
    TMR2  = 0x0000U;  // Start counting from 0
    PR2   = XFER_DELAY;
    T2CONbits.TON = 1;
}
/*${BSP::_IC2Interrupt} ....................................................*/
void  __attribute__((__interrupt__, auto_psv)) _IC2Interrupt(void) {
    /* ----------------------------- 80 symbols --------------------------------- */
    static uint16_t icprev = 0;        // previous value of a capture buffer
    static uint16_t rpmprev = 0;        // previous value of averaged rpm
    static uint32_t comm_cycle = 0;    // commutation cycle time
    static int8_t tacho_count = 0;    // step count in comm.cycle
    uint16_t tmpdata;
    uint16_t rpm;

    _IC2IF = 0;                    /* clear interrupt flag */

            do {
                tacho_count++;
                tmpdata = IC2BUF;
                comm_cycle += ( tmpdata - icprev );
                icprev = tmpdata;

                if( tacho_count == 6 ) { // last value in a cycle

                    rpm = (120000000UL/14)/comm_cycle;    // 14 pole pairs

                    comm_cycle = 0;
                    tacho_count = 0;

                    tmpdata = ewma_add( &avg_rpm, rpm );

                    if( rpmprev != tmpdata ) { // value changed

                        rpmprev = tmpdata;
                        TachoEvt* te = Q_NEW( TachoEvt, TACHO_SIG );
                        te->val = rpmprev;
                        QACTIVE_POST_X(AO_Front, (QEvt*)te, 1, 0);

                        //QS_BEGIN( CONSOLE_OUT, 0 )
                        //    QS_U16( 5, rpmprev );
                        //QS_END()
                    } // if( rpmprev != tmpdata...
                } // if( tacho_count == 6...

            } while( IC2CON1bits.ICBNE );
}

/* modified to handle small positive numbers */
/* K2R2 itoa:  convert n to characters in s  */
void itoa(uint16_t n, uint8_t s[]) {
    uint8_t i = 0;

     do {       /* generate digits in reverse order */
         s[i++] = n % 10 + '0';   /* get next digit */
     } while ((n /= 10) > 0);     /* delete it */

     s[i] = '\0';

     reverse(s);
}

/* K2R2 reverse:  reverse string s in place */
void reverse(uint8_t s[]) {
uint8_t i, j, c;

    for (i = 0, j = strlen((const char*)(s))-1; i<j; i++, j--) {
         c = s[i];
         s[i] = s[j];
         s[j] = c;
     }
}

/* EWMA-related functions */

void ewma_init( struct ewma *avg, uint8_t weight ) {

    avg->weight = QF_LOG2(weight);
    avg->internal = 0;
}

uint16_t ewma_add( struct ewma *avg, uint16_t val ) {
    avg->internal = avg->internal  ?
        (((avg->internal << avg->weight) - avg->internal) +
            val) >> avg->weight :
        (val);
    return avg->internal;
}

#if 0

/* PID-related */
// Takes current IC2 result, calculates new value for pwm
// inspired by: https://www.embeddedrelated.com/showarticle/123.php
int16_t pid_update(uint16_t tacho) {

 const int16 N = 1U;    // prop gain shift
 const int32 nmin = -(1 << (15+N));
 const int32 nmax = (1 << (15+N)) - 1;
 int16_t x_min16, x_max16;

 int16_t x, sat;
 int32_t x_integral, p_term;
 int16_t Kp, Ki2;

 int16_t error = SetRpm - tacho;    // calculate error


#endif    // 0
































